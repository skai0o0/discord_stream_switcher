<!DOCTYPE html>
<html lang="vi" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Discord Stream Switcher ‚Ä¢ Dashboard (GRID-last)</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <nav>
      <div class="navbar-left">
        <div class="navbar-logo">üéÆ Discord Stream Switcher ‚Ä¢ Dashboard</div>
        <div class="muted">(Canvas preview ‚Äì d√πng localhost ·ªü m√°y c·ªßa b·∫°n ƒë·ªÉ ch·∫°y th·ª±c)</div>
      </div>
      <div class="navbar-right">
        <button class="navbar-btn theme-btn" id="themeToggle" title="Toggle theme">
          <svg class="sun-icon" width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 4V2M12 22v-2M4.93 4.93L3.52 3.52M20.48 20.48l-1.41-1.41M4 12H2m20 0h-2M4.93 19.07l-1.41 1.41M20.48 3.52l-1.41 1.41" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><circle cx="12" cy="12" r="5" stroke="currentColor" stroke-width="2"/></svg>
          <svg class="moon-icon" width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="2" fill="currentColor"/></svg>
        </button>
      </div>
    </nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <div class="body">
          <h3>1) K·∫øt n·ªëi & Ki·ªÉm tra</h3>
          <div class="row" style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center">
            <button class="btn" onclick="testHealth()">Health</button>
            <button class="btn" onclick="testDiscord()">Discord Status</button>
          </div>
          <div class="stat">
            <div class="box"><div class="val" id="statStreams">0</div><div class="lbl">Active Streams</div></div>
            <div class="box"><div class="val" id="statCurrent">-</div><div class="lbl">Current Index</div></div>
            <div class="box"><div class="val" id="statServer">‚Äì</div><div class="lbl">Server</div></div>
          </div>
          <p class="muted" style="margin-top:10px">Server m·∫∑c ƒë·ªãnh: <span class="inline-code" id="serverUrlLbl">http://localhost:3333</span></p>
        </div>
      </section>

      <section class="card">
        <div class="body">
          <h3>2) Copy Script ƒë·ªÉ d√°n v√†o Discord (Console)</h3>
          <p class="muted">B1: M·ªü Discord ·ªü debug mode ‚Üí B2: <span class="inline-code">chrome://inspect/#devices</span> ‚Üí Inspect tab Discord ‚Üí Console ‚Üí Paste script.</p>
          <div class="row" style="margin:8px 0 12px; display:flex; gap:10px; flex-wrap:wrap">
            <button class="btn" onclick="copyTestSnippet()">üìã Copy Test Snippet</button>
            <button class="btn" onclick="copyDebugScript()">üîç Copy Debug Aria-Label Scanner</button>
            <button class="btn btn-primary" onclick="copyMainScript()">üìã Copy Main Script</button>
          </div>
          <details>
            <summary class="muted">Xem nhanh l·ªánh m·ªü Discord debug</summary>
            <div class="mono" style="margin-top:8px">%LocalAppData%\Discord\Update.exe --processStart Discord.exe --process-start-args="--remote-debugging-port=9222"</div>
          </details>
          <details style="margin-top:8px">
            <summary class="muted">H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Debug Scanner</summary>
            <div style="margin-top:8px; font-size:13px; color:var(--muted)">
              <p>1. Copy v√† paste <strong>Debug Aria-Label Scanner</strong> v√†o Discord Console</p>
              <p>2. Script s·∫Ω scan t·∫•t c·∫£ element c√≥ aria-label v√† nh√≥m ch√∫ng theo ch·ª©c nƒÉng</p>
              <p>3. K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã trong Console v·ªõi c√°c selector ƒë·ªÉ d√πng cho fullscreen mode</p>
              <p>4. Copy c√°c selector ƒë∆∞·ª£c suggest ƒë·ªÉ update code fullscreen mode</p>
            </div>
          </details>
        </div>
      </section>

      <section class="card" style="grid-column:1/-1">
        <div class="body">
          <h3>3) Stream Grid</h3>
          <div class="row" style="margin-bottom:10px; display:flex; gap:10px; flex-wrap:wrap">
            <button class="btn" onclick="refreshStreams()">Refresh Streams</button>
            <button class="btn" onclick="prevStream()">‚¨Ö Previous</button>
            <button class="btn" onclick="nextStream()">Next ‚û°</button>
          </div>
          <div class="streams" id="grid"></div>
        </div>
      </section>

      <section class="card" style="grid-column:1/-1">
        <div class="body">
          <h3>4) Self Tests</h3>
          <div class="row" style="margin-bottom:10px; display:flex; gap:10px; flex-wrap:wrap">
            <button class="btn" onclick="runSelfTests()">‚ñ∂ Run Self Tests</button>
          </div>
          <div class="test" id="testOut"></div>
        </div>
      </section>

      <section class="card" style="grid-column:1/-1">
        <div class="body">
          <h3>Logs</h3>
          <div class="log" id="log"></div>
        </div>
      </section>
    </div>
  </main>

  <!-- ===== Scripts: script snippets to copy ===== -->
  
  <!-- Debug script to scan Discord UI elements and their aria-labels -->
  <script type="text/plain" id="tpl-debug-arialabel">
// üîç Discord UI Element Scanner - Scan aria-label c·ªßa c√°c element
(function() {
  console.log('üîç Starting Discord UI Element Scanner...');
  
  // Scan common Discord UI elements
  const selectors = [
    'nav[aria-label]',
    'div[aria-label]',
    'button[aria-label]',
    'section[aria-label]',
    '[role="navigation"][aria-label]',
    '[role="button"][aria-label]',
    '[role="region"][aria-label]',
    '[role="banner"][aria-label]',
    '[role="complementary"][aria-label]'
  ];
  
  const foundElements = new Map();
  
  selectors.forEach(selector => {
    try {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        const ariaLabel = el.getAttribute('aria-label');
        if (ariaLabel && ariaLabel.trim()) {
          const key = `${el.tagName.toLowerCase()}[aria-label="${ariaLabel}"]`;
          if (!foundElements.has(key)) {
            foundElements.set(key, {
              element: el,
              ariaLabel: ariaLabel,
              selector: selector,
              classList: Array.from(el.classList).join(' ')
            });
          }
        }
      });
    } catch (e) {
      console.warn('Selector error:', selector, e);
    }
  });
  
  console.log(`üéØ Found ${foundElements.size} elements with aria-label:`);
  console.log('========================================');
  
  // Group by likely function
  const groups = {
    navigation: [],
    controls: [],
    user: [],
    chat: [],
    voice: [],
    other: []
  };
  
  foundElements.forEach((data, key) => {
    const label = data.ariaLabel.toLowerCase();
    
    if (label.includes('server') || label.includes('guild') || label.includes('channel') || 
        label.includes('thanh b√™n') || label.includes('k√™nh') || label.includes('m√°y ch·ªß')) {
      groups.navigation.push(data);
    } else if (label.includes('control') || label.includes('call') || label.includes('voice') || 
               label.includes('ƒëi·ªÅu khi·ªÉn') || label.includes('cu·ªôc g·ªçi')) {
      groups.controls.push(data);
    } else if (label.includes('user') || label.includes('account') || label.includes('profile') || 
               label.includes('ng∆∞·ªùi d√πng') || label.includes('t√†i kho·∫£n')) {
      groups.user.push(data);
    } else if (label.includes('chat') || label.includes('message') || 
               label.includes('tr√≤ chuy·ªán') || label.includes('tin nh·∫Øn')) {
      groups.chat.push(data);
    } else if (label.includes('voice') || label.includes('audio') || label.includes('sound') || 
               label.includes('√¢m thanh') || label.includes('ti·∫øng')) {
      groups.voice.push(data);
    } else {
      groups.other.push(data);
    }
  });
  
  // Display results by group
  Object.entries(groups).forEach(([groupName, items]) => {
    if (items.length > 0) {
      console.log(`\nüìÅ ${groupName.toUpperCase()} (${items.length} items):`);
      items.forEach(item => {
        console.log(`  ‚úÖ ${item.ariaLabel}`);
        console.log(`     Selector: ${item.element.tagName.toLowerCase()}[aria-label="${item.ariaLabel}"]`);
        console.log(`     Classes: ${item.classList || 'none'}`);
        console.log('     Element:', item.element);
      });
    }
  });
  
  // Export results for copy-paste
  const exportData = {
    timestamp: new Date().toISOString(),
    totalElements: foundElements.size,
    byGroup: groups,
    allSelectors: Array.from(foundElements.values()).map(item => 
      `${item.element.tagName.toLowerCase()}[aria-label="${item.ariaLabel}"]`
    )
  };
  
  console.log('\nüìã Export data (copy this for development):');
  console.log(JSON.stringify(exportData, null, 2));
  
  // Suggest selectors for fullscreen mode
  console.log('\nüéØ Suggested selectors for fullscreen mode:');
  groups.navigation.forEach(item => {
    console.log(`  '${item.element.tagName.toLowerCase()}[aria-label*="${item.ariaLabel.split(' ')[0]}"]',`);
  });
  groups.controls.forEach(item => {
    console.log(`  '${item.element.tagName.toLowerCase()}[aria-label*="${item.ariaLabel.split(' ')[0]}"]',`);
  });
  groups.user.forEach(item => {
    console.log(`  '${item.element.tagName.toLowerCase()}[aria-label*="${item.ariaLabel.split(' ')[0]}"]',`);
  });
  
  console.log('üîç Discord UI Element Scanner completed!');
  
  // Return data for further use
  return exportData;
})();
</script>

  <script type="text/plain" id="tpl-test-snippet">const tiles = [...document.querySelectorAll('div[data-selenium-video-tile] .focusTarget__54e4b[role="button"]')];
console.log('üéØ Found video tiles:', tiles.length);
const results = tiles.map((el, i)=>{
  const videoTile = el.closest('[data-selenium-video-tile]');
  const id = videoTile?.dataset?.seleniumVideoTile;
  const name = `Stream ${i+1}`;
  return { id, name };
});
console.log('üìä Individual Streams:', results);
if(!results.length){console.warn('‚ùå No streams found ‚Äì h√£y b·∫≠t multistream');}</script>

  <script type="text/plain" id="tpl-main-script">
(function(){'use strict';
  const ORDER_BOOK = new Map(); // id -> slot (·ªïn ƒë·ªãnh)
  let CURRENT_STREAM_IDS = [];   // [{id,name}]
  let CURRENT_STREAM_INDEX = 0;

  function scanTiles(){
    const btns = Array.from(document.querySelectorAll('div[data-selenium-video-tile] .focusTarget__54e4b[role="button"]'));
    return btns.map(function(btn, idx){
      const tile = btn.closest('[data-selenium-video-tile]');
      const id = tile && tile.dataset && tile.dataset.seleniumVideoTile;
      if(!id) return null;
      const name = 'Stream ' + (idx+1);
      return { id:id, name:name };
    }).filter(Boolean);
  }

  // L·ªçc b·ªè duplicate IDs (gi·ªØ c√°i ƒë·∫ßu ti√™n)
  function dedupeStreams(arr){
    const seen = new Set();
    return arr.filter(function(item){
      if(seen.has(item.id)) return false;
      seen.add(item.id);
      return true;
    });
  }

  // Th·ª© t·ª± ·ªïn ƒë·ªãnh
  function stableOrder(entries){
    const used = new Set();
    const placed = [];
    // Gi·ªØ slot c≈©
    entries.forEach(function(e){
      if(ORDER_BOOK.has(e.id)){
        const slot = ORDER_BOOK.get(e.id);
        placed.push({slot:slot, id:e.id, name:e.name});
        used.add(slot);
      }
    });
    // ID m·ªõi ‚Üí slot tr·ªëng nh·ªè nh·∫•t
    const newcomers = entries.filter(function(e){return !ORDER_BOOK.has(e.id);});
    function nextFreeSlot(){ var s=0; while(used.has(s)) s++; used.add(s); return s; }
    newcomers.forEach(function(e){ var slot = nextFreeSlot(); ORDER_BOOK.set(e.id, slot); placed.push({slot:slot, id:e.id, name:e.name}); });
    // Sort theo slot
    placed.sort(function(a,b){ return a.slot - b.slot; });
    return placed.map(function(p){ return {id:p.id, name:p.name}; });
  }

  function getCurrentStreamIds(){
    try{
      const raw = scanTiles();
      const uniq = dedupeStreams(raw);
      const ordered = stableOrder(uniq);
      return ordered;
    }catch(e){ console.error(e); return []; }
  }

  function refreshStreams(){
    CURRENT_STREAM_IDS = getCurrentStreamIds();
    if(CURRENT_STREAM_INDEX >= CURRENT_STREAM_IDS.length) CURRENT_STREAM_INDEX = Math.max(0, CURRENT_STREAM_IDS.length - 1);
    return CURRENT_STREAM_IDS;
  }

  function switchToStreamById(id){
    try{
      const sel = 'div[data-selenium-video-tile="' + CSS.escape(id) + '"] .focusTarget__54e4b[role="button"]';
      const target = document.querySelector(sel);
      if(target){ target.click(); CURRENT_STREAM_INDEX = Math.max(0, CURRENT_STREAM_IDS.findIndex(function(s){ return (s.id||s)===id; })); return true; }
      return false;
    }catch(e){ console.error(e); return false; }
  }

  function switchToStreamByIndex(i){ if(i<0||i>=CURRENT_STREAM_IDS.length) return false; const id=(CURRENT_STREAM_IDS[i].id||CURRENT_STREAM_IDS[i]); return switchToStreamById(id); }
  function switchToNextStream(){ if(!CURRENT_STREAM_IDS.length) refreshStreams(); if(!CURRENT_STREAM_IDS.length) return false; CURRENT_STREAM_INDEX=(CURRENT_STREAM_INDEX+1)%CURRENT_STREAM_IDS.length; return switchToStreamByIndex(CURRENT_STREAM_INDEX); }
  function switchToPreviousStream(){ if(!CURRENT_STREAM_IDS.length) refreshStreams(); if(!CURRENT_STREAM_IDS.length) return false; CURRENT_STREAM_INDEX=(CURRENT_STREAM_INDEX-1+CURRENT_STREAM_IDS.length)%CURRENT_STREAM_IDS.length; return switchToStreamByIndex(CURRENT_STREAM_INDEX); }

  window.DiscordStreamDeck = {
    refreshStreams: refreshStreams,
    switchToStreamById: switchToStreamById,
    switchToStreamByIndex: switchToStreamByIndex,
    switchToNextStream: switchToNextStream,
    switchToPreviousStream: switchToPreviousStream,
    getCurrentStreamIds: getCurrentStreamIds,
    getStatus: function(){ return { streams: CURRENT_STREAM_IDS.length? CURRENT_STREAM_IDS: [], currentIndex: CURRENT_STREAM_INDEX, totalStreams: CURRENT_STREAM_IDS.length }; }
  };

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(refreshStreams, 2000); });
  } else { setTimeout(refreshStreams, 2000); }

  // Hotkey: Ctrl + Shift + Q to show stream selector, Ctrl + Shift + W for switch mode
  let streamSelectorVisible = false;
  let streamSelectorEl = null;
  let switchModeActive = false;

  function createStreamSelector() {
    const el = document.createElement('div');
    el.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      z-index: 999999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      min-width: 200px;
      border: 2px solid #5865f2;
    `;
    
    const streams = CURRENT_STREAM_IDS;
    let content = '<div style="margin-bottom: 10px; font-weight: bold;">üéÆ Stream Switcher</div>';
    
    if (!streams.length) {
      content += '<div style="color: #faa61a;">No streams detected</div>';
    } else {
      content += '<div style="margin-bottom: 8px; font-size: 12px; opacity: 0.8;">Press number to switch:</div>';
      streams.forEach((stream, i) => {
        if (i < 9) { // Only show first 9 streams
          const name = stream.name || `Stream ${i+1}`;
          content += `<div style="margin: 4px 0;">${i+1}: ${name}</div>`;
        }
      });
    }
    
    content += `
      <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #444; font-size: 12px; opacity: 0.8;">
        ‚Üê ‚Üí : Previous/Next<br>
        0 : Cancel
      </div>
    `;
    
    el.innerHTML = content;
    return el;
  }

  function showStreamSelector() {
    if (streamSelectorVisible) return;
    
    refreshStreams(); // Update current streams
    streamSelectorEl = createStreamSelector();
    document.body.appendChild(streamSelectorEl);
    streamSelectorVisible = true;
    
    // Auto hide after 5 seconds
    setTimeout(hideStreamSelector, 5000);
  }

  function hideStreamSelector() {
    if (!streamSelectorVisible) return;
    
    if (streamSelectorEl) {
      streamSelectorEl.remove();
      streamSelectorEl = null;
    }
    streamSelectorVisible = false;
  }

  function toggleSwitchMode() {
    switchModeActive = !switchModeActive;
    
    if (switchModeActive) {
      refreshStreams(); // Update current streams
      console.log('ÔøΩ Switch mode ACTIVATED - Press 1-9 for streams, ‚Üê ‚Üí for prev/next, Ctrl+Shift+W to exit');
    } else {
      console.log('ÔøΩ Switch mode DEACTIVATED');
    }
  }

  document.addEventListener('keydown', function(e) {
    // Ctrl + Shift + Q to show visual selector
    if (e.ctrlKey && e.shiftKey && e.key === 'Q') {
      e.preventDefault();
      showStreamSelector();
      return;
    }
    
    // Ctrl + Shift + W to toggle switch mode (persistent silent mode)
    if (e.ctrlKey && e.shiftKey && e.key === 'W') {
      e.preventDefault();
      toggleSwitchMode();
      return;
    }
    
    // Ctrl + Shift + R to refresh streams
    if (e.ctrlKey && e.shiftKey && e.key === 'R') {
      e.preventDefault();
      refreshStreams();
      console.log('üîÑ Discord Stream Switcher: Streams refreshed');
      return;
    }
    
    // Ctrl + Shift + F to toggle sidebar for fullscreen viewing
    if (e.ctrlKey && e.shiftKey && e.key === 'F') {
      e.preventDefault();
      
      // Use aria-label selectors (more stable across accounts/servers)
      const elementsToFind = [
        // Sidebar/Guild list
        'nav[aria-label*="Server"], nav[aria-label*="Guild"], nav[aria-label*="Servers"]',
        'nav[aria-label*="Thanh b√™n"], nav[aria-label*="Danh s√°ch m√°y ch·ªß"]', // Vietnamese
        'nav[aria-label*="„Çµ„Éº„Éê„Éº"], nav[aria-label*="„ÇÆ„É´„Éâ"]', // Japanese
        'div[role="navigation"][aria-label*="server"], div[role="navigation"][aria-label*="guild"]',
        
        // Chat/Channel list
        'nav[aria-label*="Channel"], nav[aria-label*="Chat"]',
        'nav[aria-label*="K√™nh"], nav[aria-label*="Tr√≤ chuy·ªán"]', // Vietnamese
        'div[role="navigation"][aria-label*="channel"]',
        
        // User panel/bottom bar
        '[aria-label*="User area"], [aria-label*="Account"], [aria-label*="Profile"]',
        '[aria-label*="Khu v·ª±c ng∆∞·ªùi d√πng"], [aria-label*="T√†i kho·∫£n"]', // Vietnamese
        
        // Call controls
        '[aria-label*="Call controls"], [aria-label*="Voice controls"]',
        '[aria-label*="ƒêi·ªÅu khi·ªÉn cu·ªôc g·ªçi"], [aria-label*="ƒêi·ªÅu khi·ªÉn √¢m thanh"]', // Vietnamese
        
        // Fallback to class-based selectors (as backup)
        'div[data-collapsed] nav.wrapper_ef3116.guilds_c48ade',
        'div.sidebar_c48ade',
        'nav.wrapper_ef3116',
        '.title_c38106, .title_bb0d86',
        '.topControls_bfe55a.controlSection_bfe55a',
        '.bottomControls_bfe55a.controlSection_bfe55a',
        '.bar_c38106.theme-dark',
        '.leading_c38106'
      ];
      
      // Find all elements to toggle
      const elementsToToggle = [];
      elementsToFind.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            if (el && !elementsToToggle.includes(el)) {
              elementsToToggle.push(el);
            }
          });
        } catch (e) {
          // Ignore selector errors
        }
      });
      
      if (elementsToToggle.length > 0) {
        // Check if currently hidden by looking at the first found element
        const isCurrentlyHidden = elementsToToggle[0]?.style.display === 'none' || 
                                  elementsToToggle[0]?.closest('div[data-collapsed]')?.getAttribute('data-collapsed') === 'true';
        
        if (isCurrentlyHidden) {
          // Show all elements
          elementsToToggle.forEach(el => {
            el.style.display = '';
            const parentDiv = el.closest('div[data-collapsed]');
            if (parentDiv) {
              parentDiv.style.display = '';
              parentDiv.setAttribute('data-collapsed', 'false');
            }
          });
          console.log('üéÆ Discord Stream Switcher: UI elements shown - Normal view restored');
        } else {
          // Hide all elements
          elementsToToggle.forEach(el => {
            el.style.display = 'none';
            const parentDiv = el.closest('div[data-collapsed]');
            if (parentDiv) {
              parentDiv.setAttribute('data-collapsed', 'true');
            }
          });
          console.log('üéÆ Discord Stream Switcher: UI elements hidden - Clean fullscreen view enabled');
        }
        
        console.log(`üîç Found and toggled ${elementsToToggle.length} UI elements`);
      } else {
        console.log('üéÆ Discord Stream Switcher: No UI elements found to toggle');
      }
      return;
    }
    
    // Only handle other keys when selector is visible OR switch mode is active
    if (!streamSelectorVisible && !switchModeActive) return;
    
    e.preventDefault();
    
    // Numbers 1-9 to switch streams
    if (e.key >= '1' && e.key <= '9') {
      const index = parseInt(e.key) - 1;
      if (index < CURRENT_STREAM_IDS.length) {
        switchToStreamByIndex(index);
        console.log(`üéØ Switched to stream ${index + 1}: ${CURRENT_STREAM_IDS[index].name || 'Unknown'}`);
      }
      
      // Only hide selector in visual mode, keep switch mode active
      if (streamSelectorVisible) {
        hideStreamSelector();
      }
    }
    // 0 to cancel (only works in visual mode)
    else if (e.key === '0' && streamSelectorVisible) {
      hideStreamSelector();
    }
    // Arrow keys for previous/next
    else if (e.key === 'ArrowLeft') {
      switchToPreviousStream();
      console.log('‚¨ÖÔ∏è Previous stream');
      
      // Only hide selector in visual mode, keep switch mode active
      if (streamSelectorVisible) {
        hideStreamSelector();
      }
    }
    else if (e.key === 'ArrowRight') {
      switchToNextStream();
      console.log('‚û°Ô∏è Next stream');
      
      // Only hide selector in visual mode, keep switch mode active
      if (streamSelectorVisible) {
        hideStreamSelector();
      }
    }
    // Escape to cancel (only works in visual mode)
    else if (e.key === 'Escape' && streamSelectorVisible) {
      hideStreamSelector();
    }
  });

  // Confirmation message
  console.log('üéÆ Discord Stream Switcher - Main script loaded successfully!');
  console.log('‚úÖ DiscordStreamDeck is ready.');
  console.log('üéØ Hotkeys: Ctrl+Shift+Q (overlay), Ctrl+Shift+W (switch mode), Ctrl+Shift+R (refresh), Ctrl+Shift+F (fullscreen)');
})();</script>

  <script src="app.js"></script>
</body>
</html>
